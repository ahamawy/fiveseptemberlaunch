#!/usr/bin/env node
// Minimal MCP server exposing read-only SQL and migration file writer.
import fs from 'node:fs';
import path from 'node:path';
import { createClient } from '@supabase/supabase-js';
import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';

const supabaseUrl = process.env.SUPABASE_URL;
const anonKey = process.env.SUPABASE_ANON_KEY;
const serviceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;
const schema = process.env.SUPABASE_SCHEMA || 'public';

if (!supabaseUrl || !anonKey) {
  console.error('Missing SUPABASE_URL or SUPABASE_ANON_KEY');
  process.exit(1);
}

const sbAnon = createClient(supabaseUrl, anonKey, { auth: { persistSession: false } });
const sbService = serviceKey ? createClient(supabaseUrl, serviceKey, { auth: { persistSession: false } }) : null;

const server = new Server({ name: 'eqt-supabase-mcp', version: '0.1.0' }, new StdioServerTransport());

// Helper: very simple SELECT-only guard
const isSelect = (sql) => /^\s*select\b/i.test(sql.trim());

server.tool('supabase.sql.query', async ({ sql, limit = 100 }) => {
  if (!isSelect(sql)) return { error: 'Only SELECT is allowed in sql.query' };
  // Use PostgREST via supabase-js rpc? We can use /rest/v1 rpc for views or run on pg via Postgres function.
  // For dev simplicity, attempt SQL via pg rpc function if available; fallback to error.
  // Expect org to create a "rpc_exec" function for dev only; else block.
  return { ok: false, note: 'Hook this to a safe read executor (e.g., a postgres function for SELECTs only).' };
}, {
  schema: {
    type: 'object',
    properties: {
      sql: { type: 'string' },
      limit: { type: 'number' }
    },
    required: ['sql']
  }
});

server.tool('supabase.sql.migrate', async ({ filename, sql }) => {
  if (!filename || !sql) return { error: 'filename and sql required' };
  const dir = path.join(process.cwd(), 'DB', 'migrations');
  fs.mkdirSync(dir, { recursive: true });
  const p = path.join(dir, filename);
  fs.writeFileSync(p, `-- Generated by MCP\n${sql}\n`);
  return { ok: true, path: p };
}, {
  schema: {
    type: 'object',
    properties: { filename: { type: 'string' }, sql: { type: 'string' } },
    required: ['filename', 'sql']
  }
});

server.tool('supabase.storage.upload', async ({ bucket='eqt-artifacts', path: filePath, content=''} ) => {
  if (!sbService) return { error: 'service key required' };
  const { data, error } = await sbService.storage.from(bucket).upload(filePath, content, { upsert: true });
  if (error) return { error: error.message };
  return { ok: true, data };
}, {
  schema: {
    type: 'object',
    properties: {
      bucket: { type: 'string' },
      path: { type: 'string' },
      content: { type: 'string' }
    },
    required: ['path', 'content']
  }
});

server.start();
